# ARM - UBHX

不能让今天的次数白白流失，先水一篇再说吧，考驾照忙得一逼 没时间...

----

我从网上看到了一段C代码，长这样：
```c
#include <stdio.h>

int main()
{
    int a = 0x01020304;
    int b = (a & 0xF00) >> 8;
    
    print("%x\n", n);
    return 0;
}
```
输出是 0x3，也就是3，与它对应的ARM汇编长这样(我自己写的)：
```
; 一次性没法存那么大的数
MOV     R0, #0x304
MOVT    R0, #0x102
UBHX    R1, R0, #0x8, #0x4
```
其实上面的C代码是作者写出来的；这里有个指令我不知道啥意思，UBHX，我就研究了大概20分钟，总算知道怎么回事

----
### **UBHX**
作用：无符号位域提取
语法：`UBHX{cond} Rd, Rn, #lsb, #width`

> `cond`: 是一个可选的条件代码
> `Rd`: 是目标寄存器
> `Rn`: 是源寄存器
> `lsb`: 是位域中的最低有效位的位编码，范围从 0 到 31
> `width`: 是位域宽度，范围从 1 到 (32–lsb)
> 不要将 R15 用作 `Rd` 或 `Rn`。

这作用就是从Rn的地lsb位开始，取width这么大的内容给Rd；用上面汇编来说就是从R0的第8位开始，取后面4位给R1；你可能还不懂，我来细说：
> 1、上面的 0x01020304 对应二进制为 
>>`00000001 00000010 00000011 00000100`

> 4个字节，32位，没什么好说的
> 从第8位开始，也就是右移8位，python这么写 `R0 >> 8`，得到
>> `00000000 00000001 00000010 00000011`

> 那么取4位，也就是`0011`，从后面取，别找不到头脑
> 所以答案就是 0b0011 = 0x3 = 3

还没完，我还要说，上面的C代码写得很舒服，直接 `(a & 0xF00) >> 8`，我也想这么写，我用了20分钟就用在这上面，因为我菜，我新写了一个例子，用上面的就没意思了：
```
MOV     R0, #0x304
MOVT    R0, #0x102
UBHX    R1,R0,#0x4,#0x10
```
代码意思是从第四位开始取后面16位；
> 先把 `0x01020304` 搞成二进制 
>> `00000001 00000010 00000011 00000100`

> 我不知道你们发现什么奥秘没有，上面的 `0xF00` 二进制为 
>> `00000000 00000000 00001111 00000000`

> 上面是从第 8 位开始取 4 位，也就是会用到12位，而最终会操作的只有4位，所以我可以想象成二进制这样 `1111 00000000` 12位对吧，它十六进制就是 `0xF00`
> 可能我解释的很无厘头，但我就这么解决了我的问题

所以可以写成C语言：
```c
#include <stdio.h>

int mian()
{
    int a = 0x01020304;
    int b = (a & 0xFFFF0) >> 4;
    
    printf("0x%x\n", b);
    return 0;
}
```
输出 0x2030


