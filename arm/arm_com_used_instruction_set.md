# ARM常用指令集

## ARM 指令集规律含义
汇编语言是由构建机器码块的指令组成，所以ARM指令通常由`助记符`外加`一到两个`跟在后面的`操作符`组成：
> `MNEMONIC{S}{condition} {Rd}, Operand1, Operand2`

模版含义：

> `MNEMONIC`      - 指令的简称(助记符)；如ADD、MOV
> `{S}`           - 可选的拓展位，如果指令后面加了S，则需要依据计算结果更新`CPSR`标志
> `{condition}`   - 执行指令必须满足的条件
> `{Rd}`          - 用于存储指令结果的寄存器(目标)
> `Operand1`      - 第一个操作数。寄存器或直接值
> `Operand2`      - 第二个操作数(灵活)。可以是一个直接值(数字)，也可以是一个带有可选移位的寄存器

虽然`MNEMONIC、S、Rd`和`Operand1`字段很简单，但`condition`和`Operand2`字段需要更多说明。 `condition`字段与`CPSR`寄存器的值紧密相关，或者确切地说，与寄存器内特定位的值紧密相关。 `Operand2`被称为灵活操作数，因为我们可以以多种形式使用它-作为立即值(具有有限的一组值)，寄存器或带移位的寄存器。例如，我们可以将这些表达式用作`Operand2`：
> `#123`          - 立即值 (具有有限的一组值)
> `Rx`            - 寄存器Rx (例如R1、R2、R3)
> `Rx, ASR n`     - 算术右移寄存器x n位 (n范围:1 - 32)
> `Rx, LSL n`     - 逻辑左移寄存器x n位 (n范围:0 - 31)
> `Rx, LSR n`     - 逻辑右移寄存器x n位 (n范围:1 - 32)
> `Rx, ROR n`     - 循环右移(rotate right)寄存器x n位 (n范围:1 - 31)
> `Rx, RRX`       - 

这个`循环右移`和`带扩展的循环右移`有点意思，循环右ROR移其实简单来说和逻辑右移LSR差不多，但它会把从右侧移出去的位放到左侧空出的位。我先写个简单的例子：
```
mov     r1,#100
mov     r2,r1,ror #2
```
上面的代码很简单，先分析如果是逻辑右移会是什么结果:
> 1、100的二进制是`1100100`，右移3位，如果是`LSR`那就是`0001100` = 0xc
> 2、但是循环右移`ROR`就不同，它会把移掉的`100`放到左边，就变成了`1001100` = 0x4c
> 3、不过上面2是错的，因为100的二进制完全体为`00000000 00000000 00000000 01100100`，将移掉的`100`放到左边就是`10000000 00000000 00000000 00001100` = 0x8000000c。
> CPSR中的标志N、Z、C也会改变，内容分别为1、0、1。N为1是因为循环右移后的100的二进制最高位为1，如果算有符号位的话这就是个负数；而Z为0是因为结果不是0；C为1是因为100右移3位中的最后一位是1。

