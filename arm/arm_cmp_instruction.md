# ARM - CMP


## 说明

**CMP(compare)** 指令进行比较两个操作数的大小
语法：` CMP{cond} Rn, Operand2 `

> `cond` 是一个可选的条件代码
> `Rn` 是存放第一个操作数的 ARM 寄存器
> `Operand2` 是一个灵活的第二操作数

第一个操作减去第二个操作数，但不会将结果存入任何寄存器中，它只会更新 **FLAG** 的 **CF，ZF，OF，AF，PF** 标志。

----

执行指令后：

> **ZF=1** 则说明两个数相等，因为zero为1说明结果为0

当无符号时：

> **CF=1** 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1 < oprd2
> **CF=0** 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1 > oprd2

当有符号时：

> 若**SF=0，OF=0** 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1 > oprd2
> 若**SF=1，OF=0** 则说明了此时的值为负数，没有溢出，则为oprd1 < oprd2
> 若**SF=0，OF=1** 则说明了此时的值为正数，有溢出，可以看出oprd1 < oprd2
> 若**SF=1，OF=1** 则说明了此时的值为负数，有溢出，可以看出oprd1 > oprd2 

----
##简单例子

C代码:
```c
int a = 10;
int b = 0;
if (a > b) a ++;
else b++;
```

对应arm汇编:

```
MOV	R1,#0xa		; R1(a) = 10
MOV	R2,#0x0		; R2(b) = 0
CMP	R1,R2		; R1(a) - R2(b)
ADDHI	R1,R1,#1	; HI表示无符号数大于high；如果R1(a) > R2(b)，R1(a)=R1(a)+1
ADDLS	R2,R2,#1	; LS表示无符号数小鱼或者等于less；如果R2(b) > R1(a)，R2(b)=R2(b)+1
```

所以最后寄存器R1=0xb，R2=0x0

----

标记含义：
|标记|含义|
|--|
|N(Negative)|指令结果为负值时置1|
|Z(Zero)|指令结果为零值时置1|
|C(Carry)|对于加法有进位则置1，对于减法有借位则置0|
|V(Overflow)|指令结果不能用32位的二进制补码存储，即发生了溢出时置1|
|E(Endian)|小端序置0，大端序置1|
|T(Thumb)|当为Thumb模式时置1，ARM模式置0|
|M(Mode)|当前的权限模式(用户态，内核态)|
|J(Jazelle)|允许ARM处理器去以硬件执行java字节码的状态标示|



